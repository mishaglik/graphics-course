# Локальный Shadertoy 2

**Зависимости: [shadertoy2](/tasks/shadertoy2/), [local_shadertoy1](/tasks/local_shadertoy1/)**.

В данном задании на предстоит наконец-то познакомиться с тем, как запускать традиционный графический пайплайн на Вулкане.

## Перед началом

 1. Скопируйте в данную папку решение задания [локальный Shadertoy 1](/tasks/local_shadertoy1/).
    Не забудьте поменять название таргета в CMakeLists.txt чтобы не было конфликтов, а также поменять макрос используемый для получения путей до шейдеров.
 2. Убедитесь, что вы не потеряли решение задания [Shadertoy 2](/tasks/shadertoy2/).
 3. Вспомните, как работают графические пайплайны и рендер-пассы в Вулкане.
 4. Обратите внимание, что чтобы использовать в шейдерах заголовочный файл `cpp_glsl_compat.h` необходимо подключить в `CMakeLists.txt` таргет `render_utils`, а чтобы использовать для загрузки изображений `stb_image.h` необходимо подключить таргет `scene`.

## Задание

#### Шаг 1

Поменяйте ваш код так, чтобы картинка считалась не в вычислительном шейдере, а во фрагментном.
Вместо compute-пайплайна используйте графический.
Вместо storage-текстур для записи результата шейдера используйте колор-атачменты.
Для этого вам, разумеется, придётся поместить запуск пайплайна в рендер-пасс.
Самый просто способ сделать это &mdash; использовать возможности Этны, поглядывая за вдохновением в семпл [shadowmap](/samples/shadowmap/).
Альтернативно можете самостоятельно использовать dynamic rendering Вулкана, поддерживаемый без расширений в нашей версии Вулкана.
Наконец, как самый сложный (и не сильно полезный) вариант, можете использовать "классические" объекты рендер-пассов вулкана.
Если вы вдруг использовали текстуры в первой домашке, пока что их придётся открутить.

#### Шаг 2

Замените текущий шейдер на написанный вами в задании [Shadertoy 2](/tasks/shadertoy2/).
Так как на самом деле это не один шейдер, а два (один генерирует процедурную текстуру, другой использует), вам придётся сделать ещё один рендер-пасс, ещё один пайплайн, запустить его перед основным и "скормить" на вход основному шейдеру вспомогательную процедурную текстуру.
Непроцедурные текстуры пока что открутите из шейдера.

### Шаг 3

Также вам придётся загрузить какую-нибудь картинку из [папки текстур](/resources/textures/), протянуть её в шейдер и использовать в качестве текстуры для трипланарной проекции.
Для загрузки файла картинки используйте `stb_image.h` (не забыв подключить `render_utils`), а для загрузки картинки на GPU используйте `etna::BlockingTransferHelper`.

### Бонусный уровень

- Разберитесь как загружать кубмапы и верните в ваш шейдер скайбокс.
  Ассет скайбокса вам придётся найти в интернете самостоятельно, желательно под лицензией CC0.
- Сгенерируйте загруженным текстурам MIP-уровни при помощи команды `blit`.

## Полезные материалы

 1. https://docs.vulkan.org/spec/latest/index.html &mdash; единый ресурс всего про Vulkan (документация, туториалы, гайды)
 2. https://www.khronos.org/opengl/wiki/OpenGL_Shading_Language &mdash; справочник по языку GLSL
 3. https://github.com/KhronosGroup/GLSL/blob/main/extensions/khr/GL_KHR_vulkan_glsl.txt &mdash; "дельта" поверх спецификации GLSL, адаптирующая его для работы с Vulkan вместо OpenGL.
