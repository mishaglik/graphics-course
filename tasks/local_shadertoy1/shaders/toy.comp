#version 430

layout(local_size_x = 32, local_size_y = 32) in;

layout(binding = 0, rgba8) uniform image2D resultImage;

layout(push_constant) uniform params
{
  float iTime;
} pushConstant;


const vec3  eye      = vec3  (0, 0, 10);
const float period   = 22.;
const vec3  light    = vec3  ( 5.3,  -1.6 + 6.0 + 0.32, 0.5 * period - 0. * period);
const int   maxSteps = 1000;
const float eps      = 1e-5;

float unionD(float d1)
{
    return d1;
}


float unionD(float d1, float d2)
{
    return min(d1, d2);
}

float unionD(float d1, float d2, float d3)
{
    return min(d1, min(d2, d3));
}

float unionD(float d1, float d2, float d3, float d4)
{
    return min(min(d1, d2), min(d3, d4));
}

vec4 unionD(vec4 d1)
{
    return d1;
}

vec4 unionD(vec4 d1, vec4 d2)
{
    return (d1.w < d2.w) ? d1 : d2;
}

vec4 unionD(vec4 d1, vec4 d2, vec4 d3)
{
    return unionD(d1, unionD(d2, d3));
}

vec4 unionD(vec4 d1, vec4 d2, vec4 d3, vec4 d4)
{
    return unionD(unionD(d1, d2), unionD(d3, d4));
}

float intersect(float d1, float d2)
{
    return max(d1, d2);
}

float subtract(float d1, float d2)
{
    return max(-d1, d2);
}

vec4 intersect(vec4 d1, vec4 d2)
{
    return (d1.w < d2.w) ? d2 : d1;
}

vec4 subtract(vec4 d1, vec4 d2)
{
    d1.w = -d1.w;
    return (d1.w < d2.w) ? d2 : d1;
}

// Rotation matrix around the X axis.
mat3 rotateX(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
        vec3(1, 0,  0),
        vec3(0, c, -s),
        vec3(0, s,  c)
    );
}

// Rotation matrix around the Y axis.
mat3 rotateY(float theta) {
    float c = cos(theta);
    float s = sin(theta);
    return mat3(
        vec3(c,  0, s),
        vec3(0,  1, 0),
        vec3(-s, 0, c)
    );
}

float dPlane ( in vec3 p, vec4 n )
{
    return dot ( p, n.xyz ) + n.w;
}

float dSphere ( in vec3 p, in vec3 c, in float r )
{
        return length ( p - c ) - r;
}



float length8 ( in vec2 p )
{
    return pow ( pow ( abs(p.x), 8.0 ) + pow ( abs(p.y), 8.0 ), 1.0/ 8.0 );
}

float length8 ( in vec3 p )
{
    return pow ( pow ( abs(p.x), 8.0 ) + pow ( abs(p.y), 8.0 ) + pow ( abs(p.z), 8.0 ), 1.0/ 8.0 );
}

float dCylinder ( in vec3 pos, in vec3 a, in vec3 b, in float r )
{
    vec3 pt    = pos;
    vec3  ba   = b  - a;
    vec3  pa   = pt - a;
    float baba = dot(ba,ba);
    float paba = dot(pa,ba);
    float x    = length(pa*baba-ba*paba) - r*baba;
    float y   = abs(paba-baba*0.5)-baba*0.5;
    float x2 = x*x;
    float y2 = y*y*baba;
    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));

    return sign(d)*sqrt(abs(d))/baba;
}

float dCylinderl8 ( in vec3 pos, in vec3 a, in vec3 b, in float r )
{
    vec3 pt    = pos;
    vec3  ba   = b  - a;
    vec3  pa   = pt - a;
    float baba = dot(ba,ba);
    float paba = dot(pa,ba);
    float x    = length8(pa*baba-ba*paba) - r*baba;
    float y   = abs(paba-baba*0.5)-baba*0.5;
    float x2 = x*x;
    float y2 = y*y*baba;
    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));

    return sign(d)*sqrt(abs(d))/baba;
}

float dConeCapped ( in vec3 pos, in vec3 st, in float h, in float r1, in float r2 )
{
    vec3 pt = pos - st;
    vec2 q  = vec2 ( length ( pt.xz ), pt.y );
    vec2 k1 = vec2 ( r2, h );
    vec2 k2 = vec2 ( r2 - r1, 2.0*h );
    vec2 ca = vec2 ( q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);
    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2, k2), 0.0, 1.0 );
    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;

    return s*sqrt( min(dot(ca, ca),dot(cb, cb)) );
}

float dTorus ( vec3 p, vec2 t )
{
        vec2    q = vec2 ( length8 ( p.xz ) - t.x, p.y );

        return length8 ( q ) - t.y;
}

float dBox ( in vec3 pos, in vec3 size )
{
    vec3 pt = pos - size;

    return length ( max ( pt, 0.0 ) ) + min ( max ( pt.x, max ( pt.y, pt.z ) ), 0.0 );
}

float dBox(in vec3 pos, in vec3 p1, in vec3 p2)
{
    return subtract(dBox(pos, p1), dBox(pos, p2));
}


float smin ( float a, float b, float k )
{
        float res = exp ( -k*a ) + exp ( -k*b );
        return -log ( res ) / k;
}


float smoothUnion ( float d1, float d2, float k ) 
{
    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );

    return mix( d2, d1, h ) - k*h*(1.0-h); 
}


float dRazmetka(in vec3 p, in vec3 pos, in vec3 size)
{
    p = p - pos;
    p.z = mod(p.z, size.z * 2.);
    p = p / size;
    
    return length8(p) - 1.;
    
}

float dTrueBox(in vec3 p, in vec3 pos, in vec3 size)
{
    p = p - pos;
    p = p / size;
    p = abs(p);
    return max(p.x, max(p.y, p.z)) - 1.;
}

vec4 lamp(in vec3 p, in vec3 pos)
{
    vec3 height = vec3(0.0, 6.0, 0.0);
    float topR = 0.1;
    
    return vec4(1., 1., 1., unionD( 
            smoothUnion(
                dCylinder(p, pos, pos + 0.3 * height, topR),
                dCylinder(p, pos, pos +       height, topR),
                0.3),
            unionD(
                unionD(
                    dCylinderl8(p, pos + height + vec3(  0.0,  0.0,  topR), pos + height + vec3(         0.0, 0.5,  topR + 0.3), 0.01),
                    dCylinderl8(p, pos + height + vec3(  0.0,  0.0, -topR), pos + height + vec3(         0.0, 0.5, -topR - 0.3), 0.01),
                    dCylinderl8(p, pos + height + vec3(  topR, 0.0,   0.0), pos + height + vec3(  topR + 0.3, 0.5,         0.0), 0.01),
                    dCylinderl8(p, pos + height + vec3( -topR, 0.0,   0.0), pos + height + vec3( -topR - 0.3, 0.5,         0.0), 0.01)
                ),
                subtract(
                    dConeCapped(p, pos + height + vec3(0, 0.699, 0), 0.2, topR + 0.28, 0.02),
                    dConeCapped(p, pos + height + vec3(0, 0.700, 0), 0.2, topR + 0.30, 0.10)
                )
            )
        ));
}


vec4 road(in vec3 p)
{
    return unionD(
        vec4(0.1, 0.1, 0.1, dPlane (p, vec4 (0, 1, 0, 1.8))),
        vec4(0.8, 0.8, 0., dRazmetka(p, vec3(2.5, -1.8, 1), vec3(0.2, 0.1, 2))),
        vec4(0.3, 0.3, 0.3, unionD(
            subtract(dBox (p, vec3(-100, 0.1, 50.1)), dBox(p, vec3(0,   -1.6, 50))),
            subtract(dBox (p, vec3(   5, 0.1, 50.1)), dBox(p, vec3(100, -1.6, 50)))
            ))
        );
    
}

vec4 housing(in vec3 p)
{
    vec3 pr = p; 
    pr.z = mod(pr.z, 3.1); 
    pr.y -= 1.;
    if (pr.y > 0.) {
        pr.y = mod(pr.y, 4.1);
    }
    return subtract(
        vec4(0.0, 0.0, 0.0, dTrueBox(pr, vec3(-1., 1, 0.7), vec3(0.1, 1.4, 0.7))),
        vec4(0.4, 0.2, 0.0, dBox(p, vec3(-1, 30, 50)))
        );
}

vec4 sdf ( in vec3 p, in mat3 m)
{
   vec3 q = m * p;
   //q = p;
   vec3 qr = q;
   qr.z = mod(qr.z, period);
   return unionD(
        road(q), 
        lamp(qr, vec3(5.3, -1.6, 0.5 * period)),
        housing(q)
    );
}


vec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m, out vec4 surf)
{
        vec3    p         = from;
        float   totalDist = 0.0;
        float  prec = 0.99;
        hit = false;
        
        for ( int steps = 0; steps < maxSteps; steps++ )
        {
                surf = sdf ( p, m);
                float dist = prec * surf.w;
        
                if ( dist < eps )
                {
                        hit = true;
                        break;
                }
    
                totalDist += dist;

                if ( totalDist > 140.0 )
                        break;

                p += dist * dir;
        }

        return p;
}

vec3 generateNormal ( vec3 z, float d, in mat3 m )
{
    float e   = max (d * 0.5, eps );
    vec4 sf;
    float dx1 = sdf(z + vec3(e, 0, 0), m).w;
    float dx2 = sdf(z - vec3(e, 0, 0), m).w;
    float dy1 = sdf(z + vec3(0, e, 0), m).w;
    float dy2 = sdf(z - vec3(0, e, 0), m).w;
    float dz1 = sdf(z + vec3(0, 0, e), m).w;
    float dz2 = sdf(z - vec3(0, 0, e), m).w;
    
    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );
}

float ambientOcclusion ( in vec3 pos, in vec3 normal, in mat3 m)
{
    float occ = 0.0;
    float sca = 1.0;
    vec4 sf;
    for ( int i = 0; i < 5; i++ )
    {
        float h = 0.01 + 0.12*float(i)/4.0;
        float d = sdf ( pos + h*normal, m).w;

        occ += (h-d)*sca;
        sca *= 0.95;

        if ( occ > 0.35 ) 
            break;
    }

    return clamp ( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*normal.y);
}

vec4 getLight(vec3 p, vec3 src, mat3 m, vec3 n)
{
    bool hit;
    vec3  l  = normalize( src - p );
    vec4 sf;
    vec3 s = trace(src, -l, hit, m, sf);
    vec4 shade = vec4(1., 1., 1., 1.);
    
    if(length(s - p) > 0.4)
    {
        shade = 0.33 * sf;
    }
    
    
    vec3  eyer = eye;
    eyer.z = mod(eyer.z, period) - 7.;
    vec3  v  = normalize        ( eyer - p );
    float nl = max ( 0.0, dot ( n, l ) );
    vec3  h  = normalize ( l + v );
    float hn = max ( 0.0, dot ( h, n ) );
    float sp = pow ( hn, 150.0 );

    return shade * (0.7*ambientOcclusion(p, n, m)*vec4 ( nl ) + 0.5 * sp * vec4 ( 1, 1, 1, 1 ));
    
}

int hash( int x ) {
    x += ( x << 10u );
    x ^= ( x >>  6u );
    x += ( x <<  3u );
    x ^= ( x >> 11u );
    x += ( x << 15u );
    return x;
}



void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    bool hit;
    vec3 meye =  eye;
    mat3 m = mat3(vec3(1,0,0), vec3(0,1,0), vec3(0,0,1));
    
    vec2 scale = 9.0 * imageSize(resultImage).xy / max ( imageSize(resultImage).x, imageSize(resultImage).y ) ;
    vec2 uv    = scale * ( fragCoord / imageSize(resultImage).xy - vec2 ( 0.5 ) );
    vec3 dir   = normalize ( vec3 ( uv, 0 ) - meye );
    vec4 color = vec4 ( 0, 0, 0, 1 );
    vec4 surf  = vec4 ( 1, 1, 1, 1 );
    vec3 p     = trace ( meye, dir, hit, m, surf);
    float iTime = pushConstant.iTime;

        if ( hit )
        {       
                vec3 pr = p;
                pr.z = mod(pr.z, period);
                
                color = surf * getLight(pr, light, m, generateNormal( p, 1e-6, m )) ;//+ getLight(pr, light + vec3(0, 0, 15), m);
                float id =  -floor(p.z / period);
                if (hash(int(iTime)) % 100 == int(id)) {
                    color = color * pow(min(1., abs(sin(30. * iTime) + cos(2. * iTime))), 100.);
                }
                
        
        if (dot(color, vec4(1,1,1,0)) < 0.1) {
            color =  0.1 * ambientOcclusion(p, generateNormal( p, 1e-5, m ), m) * surf;
        }
        } 

    // Output to screen
    fragColor = color;
}

void main()
{
  ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
  vec4 color;
  mainImage(color, uv);
// Final rotation of image
  uv.y = imageSize(resultImage).y - uv.y;

  if (uv.x < imageSize(resultImage).x && uv.y < imageSize(resultImage).y)
    imageStore(resultImage, uv, color);
}
